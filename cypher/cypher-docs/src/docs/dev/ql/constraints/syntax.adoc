[[administration-constraints-syntax]]
= Syntax

[abstract]
--
Syntax for how to manage constraints used for ensuring data integrity.
--


== Syntax for creating constraints

Best practice is to give the constraint a name when it is created.
If the constraint is not explicitly named, it will get an auto-generated name.

The constraint name must be unique among both indexes and constraints.

The create command is optionally idempotent, with the default behavior to throw an error if you attempt to create the same constraint twice.
With `IF NOT EXISTS`, no error is thrown and nothing happens should a constraint with the same name or same schema and constraint type already exist.
It may still throw an error should a conflicting index or constraint exist.

Index provider and configuration for the backing index can be specified using the `OPTIONS` clause.


=== Create a unique node property constraint

[source, cypher, role=noplay]
----
CREATE CONSTRAINT [constraint_name] [IF NOT EXISTS]
ON (n:LabelName)
ASSERT n.propertyName IS UNIQUE
[OPTIONS "{" option: value[, ...] "}"]
----

=== [enterprise-edition]#Create a node property existence constraint#

[source, cypher, role=noplay]
----
CREATE CONSTRAINT [constraint_name] [IF NOT EXISTS]
ON (n:LabelName)
ASSERT n.propertyName IS NOT NULL
----

=== [enterprise-edition]#Create a relationship property existence constraint#

[source, cypher, role=noplay]
----
CREATE CONSTRAINT [constraint_name] [IF NOT EXISTS]
ON ()-"["R:RELATIONSHIP_TYPE"]"-()
ASSERT R.propertyName IS NOT NULL
----

=== [enterprise-edition]#Create a node key constraint#

[source, cypher, role=noplay]
----
CREATE CONSTRAINT [constraint_name] [IF NOT EXISTS]
ON (n:LabelName)
ASSERT (n.propertyName_1,
n.propertyName_2,
…
n.propertyName_n)
IS NODE KEY
[OPTIONS "{" option: value[, ...] "}"]
----

== Syntax for dropping constraints

=== Drop a constraint

The drop command is optionally idempotent, with the default behavior to throw an error if you attempt to drop the same constraint twice.
With `IF EXISTS`, no error is thrown and nothing happens should the constraint not exist.

[source, cypher, role=noplay]
----
DROP CONSTRAINT constraint_name [IF EXISTS]
----

=== [deprecated]#Drop a unique constraint without specifying a name#

[source, cypher, role=noplay]
----
DROP CONSTRAINT
ON (n:LabelName)
ASSERT n.propertyName IS UNIQUE
----

=== [deprecated]#Drop an exists constraint without specifying a name#

[source, cypher, role=noplay]
----
DROP CONSTRAINT
ON (n:LabelName)
ASSERT EXISTS (n.propertyName)
----

=== [deprecated]#Drop a relationship property existence constraint without specifying a name#

[source, cypher, role=noplay]
----
DROP CONSTRAINT
ON ()-"["R:RELATIONSHIP_TYPE"]"-()
ASSERT EXISTS (R.propertyName)
----

=== [deprecated]#Drop a node key constraint without specifying a name#

[source, cypher, role=noplay]
----
DROP CONSTRAINT
ON (n:LabelName)
ASSERT (n.propertyName_1,
n.propertyName_2,
…
n.propertyName_n)
IS NODE KEY
----

== Syntax for listing constraints

List constraints in the database, either all or filtered on type.

[source, cypher, role=noplay]
----
SHOW [ALL\|UNIQUE\|NODE [PROPERTY] EXIST[ENCE]\|RELATIONSHIP [PROPERTY] EXIST[ENCE]\|[PROPERTY] EXIST[ENCE]\|NODE KEY] CONSTRAINT[S]
    [YIELD { * \| field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]
    [WHERE expression]
    [RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]
----

[NOTE]
When using the `RETURN` clause, the `YIELD` clause is mandatory and may not be omitted.
