[[administration-constraints-syntax]]
= Syntax

[abstract]
--
Syntax for how to manage constraints used for ensuring data integrity.
--

.Syntax for managing constraints
[options="header", width="100%", cols="5a,3, 3a"]
|===
| Command | Description | Comment

| [source, cypher, role=noplay]
----
CREATE CONSTRAINT [constraint_name] [IF NOT EXISTS]
ON (n:LabelName)
ASSERT n.propertyName IS UNIQUE
[OPTIONS "{" option: value[, ...] "}"]
----
| Create a unique node property constraint.
.4+.^| Best practice is to give the constraint a name when it is created.
If the constraint is not explicitly named, it will get an auto-generated name.

The constraint name must be unique among both indexes and constraints.

The command is optionally idempotent, with the default behavior to throw an error if you attempt to create the same constraint twice.
With `IF NOT EXISTS`, no error is thrown and nothing happens should a constraint with the same name or same schema and constraint type already exist.
It may still throw an error should a conflicting index or constraint exist.

Index provider and configuration for the backing index can be specified using the `OPTIONS` clause.

| [source, cypher, role=noplay]
----
CREATE CONSTRAINT [constraint_name] [IF NOT EXISTS]
ON (n:LabelName)
ASSERT n.propertyName IS NOT NULL
----
| [enterprise-edition]#Create a node property existence constraint.#
| [source, cypher, role=noplay]
----
CREATE CONSTRAINT [constraint_name] [IF NOT EXISTS]
ON ()-"["R:RELATIONSHIP_TYPE"]"-()
ASSERT R.propertyName IS NOT NULL
----
| [enterprise-edition]#Create a relationship property existence constraint.#
| [source, cypher, role=noplay]
----
CREATE CONSTRAINT [constraint_name] [IF NOT EXISTS]
ON (n:LabelName)
ASSERT (n.propertyName_1,
n.propertyName_2,
…
n.propertyName_n)
IS NODE KEY
[OPTIONS "{" option: value[, ...] "}"]
----
| [enterprise-edition]#Create a node key constraint.#
| [source, cypher, role=noplay]
----
DROP CONSTRAINT constraint_name [IF EXISTS]
----
| Drop a constraint.
| The command is optionally idempotent, with the default behavior to throw an error if you attempt to drop the same constraint twice.
With `IF EXISTS`, no error is thrown and nothing happens should the constraint not exist.
| [source, cypher, role=noplay]
----
SHOW [ALL\|UNIQUE\|NODE [PROPERTY] EXIST[ENCE]\|RELATIONSHIP [PROPERTY] EXIST[ENCE]\|[PROPERTY] EXIST[ENCE]\|NODE KEY] CONSTRAINT[S]
    [YIELD { * \| field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]
    [WHERE expression]
    [RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]
----
| List constraints in the database, either all or filtered on type.
| When using the `RETURN` clause, the `YIELD` clause is mandatory and may not be omitted.
| [source, cypher, role=noplay]
----
DROP CONSTRAINT
ON (n:LabelName)
ASSERT n.propertyName IS UNIQUE
----
| Drop a unique constraint without specifying a name.
.4+.^| [deprecated]#This syntax is deprecated.#
| [source, cypher, role=noplay]
----
DROP CONSTRAINT
ON (n:LabelName)
ASSERT EXISTS (n.propertyName)
----
| Drop an exists constraint without specifying a name.
| [source, cypher, role=noplay]
----
DROP CONSTRAINT
ON ()-"["R:RELATIONSHIP_TYPE"]"-()
ASSERT EXISTS (R.propertyName)
----
| Drop a relationship property existence constraint without specifying a name.
| [source, cypher, role=noplay]
----
DROP CONSTRAINT
ON (n:LabelName)
ASSERT (n.propertyName_1,
n.propertyName_2,
…
n.propertyName_n)
IS NODE KEY
----
| Drop a node key constraint without specifying a name.
|===
